
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON HORIZON: Cyberpunk Space Shooter</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-pink: #ff00ff;
            --neon-cyan: #00ffff;
            --neon-purple: #bc13fe;
            --neon-green: #00ff00;
            --neon-red: #ff0055;
            --neon-teal: #00ffaa;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050011;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Prevent mobile scrolling */
            user-select: none;
            cursor: none; /* Hide default cursor */
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to controls */
        }
        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border: 2px solid var(--neon-red);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px var(--neon-red);
            transition: all 0.1s;
            pointer-events: none;
            z-index: 20;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: white;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }
        #crosshair.locked {
            border-color: var(--neon-green);
            box-shadow: 0 0 20px var(--neon-green), inset 0 0 10px var(--neon-green);
            transform: translate(-50%, -50%) scale(0.8);
        }

        /* HUD */
        #score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--neon-cyan);
            font-size: 24px;
            text-shadow: 0 0 10px var(--neon-cyan);
            font-weight: 700;
        }
        .label { font-size: 14px; color: var(--neon-purple); }
        
        #store-container {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
        }
        #buy-drone-btn {
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--neon-green);
            color: var(--neon-green);
            padding: 8px 16px;
            font-size: 14px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-shadow: 0 0 5px var(--neon-green);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transition: all 0.2s;
            opacity: 0.5;
        }
        #buy-drone-btn.available {
            opacity: 1;
            background: rgba(0, 255, 0, 0.1);
        }
        #buy-drone-btn:hover.available {
            background: var(--neon-green);
            color: #000;
            box-shadow: 0 0 20px var(--neon-green);
        }

        /* Game Over Screen */
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border: 2px solid var(--neon-pink);
            box-shadow: 0 0 20px var(--neon-pink), inset 0 0 20px var(--neon-pink);
            backdrop-filter: blur(5px);
            cursor: default;
        }
        h1 {
            color: var(--neon-pink);
            font-size: 48px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            text-shadow: 0 0 15px var(--neon-pink);
        }
        button.restart-btn {
            background: transparent;
            border: 2px solid var(--neon-cyan);
            color: var(--neon-cyan);
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--neon-cyan);
            transition: all 0.2s;
        }
        button.restart-btn:hover {
            background: var(--neon-cyan);
            color: #000;
            box-shadow: 0 0 30px var(--neon-cyan);
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Shown via JS detection */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 150px;
            height: 150px;
            border: 2px dashed rgba(0, 255, 255, 0.3);
            border-radius: 50%;
        }
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px var(--neon-cyan);
            pointer-events: none;
        }
        #fire-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
        }
        #fire-hint {
            position: absolute;
            bottom: 80px;
            right: 60px;
            color: rgba(255, 0, 255, 0.5);
            border: 2px solid rgba(255, 0, 255, 0.5);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Instructions Overlay */
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <!-- Custom Crosshair -->
        <div id="crosshair"></div>

        <div id="score-board">
            <div class="label">SCORE</div>
            <div id="score-val">0</div>
        </div>
        
        <div id="store-container">
            <button id="buy-drone-btn">GET DRONE (500 PTS)</button>
        </div>

        <div id="game-over">
            <h1>SYSTEM FAILURE</h1>
            <p style="color:white; margin-bottom: 20px;">FINAL SCORE: <span id="final-score">0</span></p>
            <button id="restart-btn" class="restart-btn">REBOOT SYSTEM</button>
        </div>

        <div id="instructions">WASD / ARROWS to Move &nbsp;|&nbsp; MOUSE to Aim &nbsp;|&nbsp; SPACE to Shoot</div>
    </div>

    <div id="mobile-controls">
        <div id="joystick-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="fire-zone">
            <div id="fire-hint">FIRE</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GAME CONFIGURATION ---
        const CONFIG = {
            speed: 20, // Reduced from 35 for slower gameplay
            shipSpeed: 0.8, // Lateral movement speed
            shipBoundX: 18,
            shipBoundY: 10,
            fireRate: 0.15, // Seconds between shots
            droneFireRate: 0.5,
            droneCost: 500,
            enemyHP: 100,
            playerDmg: 100,
            droneDmg: 25,
            colors: {
                bg: 0x050011,
                grid: 0xbc13fe, 
                sun: 0xffaa00,
                ship: 0x00ffff, // Cyan
                enemy: 0x00ffaa, // Teal/Turquoise (Changed from Pink)
                laser: 0x00ffff,
                drone: 0x00ff00,
                droneLaser: 0x00ff00,
                trailStart: 0x00ff00,
                trailEnd: 0xffaa00
            }
        };

        // --- STATE ---
        let state = {
            score: 0,
            isRunning: true,
            isPaused: false,
            hasDrone: false,
            lastTime: 0,
            lastShot: 0,
            lastDroneShot: 0,
            input: { x: 0, y: 0, shoot: false },
            mouse: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            lockedTarget: null
        };
        
        window.addEventListener('message', (e) => {
             if (e.data && e.data.type === 'PAUSE_GAME') {
                 state.isPaused = e.data.payload;
                 if (!state.isPaused) clock.getDelta();
             }
        });

        // --- SETUP SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.bg);
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 3, 12);
        camera.lookAt(0, 0, -20);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        container.appendChild(renderer.domElement);

        // --- POST PROCESSING ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 2.0; // Intense glow
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ASSETS & GENERATION ---

        // 1. The Retro Sun (Procedural Shader)
        const sunGeo = new THREE.CircleGeometry(30, 64);
        const sunMat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor1: { value: new THREE.Color(0xffd700) }, // Gold
                uColor2: { value: new THREE.Color(0xff00ff) }  // Pink
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                
                void main() {
                    // Gradient
                    vec3 color = mix(uColor2, uColor1, vUv.y);
                    
                    // Stripes
                    float stripes = 1.0;
                    float y = vUv.y;
                    float stripeFreq = 20.0; // Number of stripes
                    
                    // Calculate moving stripes
                    float stripeVal = sin(y * stripeFreq - uTime * 2.0);
                    float thickness = 0.1 + (y * 0.8); // Stripes get thinner near bottom
                    
                    if (stripeVal > 0.9 - (y * 0.5)) { // Cutout logic
                        discard;
                    }
                    
                    gl_FragColor = vec4(color, 1.0);
                    // Bloom boost
                    if(vUv.y > 0.1) gl_FragColor.rgb *= 1.5; 
                }
            `,
            transparent: true
        });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        sun.position.set(0, 10, -80);
        scene.add(sun);

        // 2. Moving Grid - REMOVED AS PER REQUEST
        // const gridHelper = new THREE.GridHelper(200, 100, CONFIG.colors.grid, CONFIG.colors.grid);
        // gridHelper.position.y = -5;
        // scene.add(gridHelper);

        // 3. Stars (Custom Geometry)
        const starGeo = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starPos[i] = (Math.random() - 0.5) * 300;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.5});
        const starField = new THREE.Points(starGeo, starMat);
        scene.add(starField);

        // --- PLAYER SHIP & DRONE ---
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        // Ship
        const shipMat = new THREE.MeshStandardMaterial({ 
            color: 0x222222, 
            roughness: 0.4,
            metalness: 0.8
        });
        const engineMat = new THREE.MeshBasicMaterial({ color: 0xff0055 });

        const bodyGeo = new THREE.ConeGeometry(0.5, 2, 4);
        bodyGeo.rotateX(Math.PI / 2);
        const body = new THREE.Mesh(bodyGeo, shipMat);
        playerGroup.add(body);

        const wingGeo = new THREE.BufferGeometry();
        const wingVertices = new Float32Array([
            0, 0, 0.5,  1.5, 0, 1.5,  0, 0, -0.5,
            0, 0, 0.5,  -1.5, 0, 1.5, 0, 0, -0.5
        ]);
        wingGeo.setAttribute('position', new THREE.BufferAttribute(wingVertices, 3));
        wingGeo.computeVertexNormals();
        const wings = new THREE.Mesh(wingGeo, shipMat);
        playerGroup.add(wings);

        const edges = new THREE.EdgesGeometry(bodyGeo);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: CONFIG.colors.ship }));
        playerGroup.add(line);
        
        const engineLight = new THREE.PointLight(CONFIG.colors.ship, 2, 10);
        engineLight.position.set(0, 0, 1);
        playerGroup.add(engineLight);

        const thrusterGeo = new THREE.ConeGeometry(0.2, 1, 8);
        thrusterGeo.rotateX(Math.PI / 2);
        const thruster = new THREE.Mesh(thrusterGeo, engineMat);
        thruster.position.z = 1.2;
        playerGroup.add(thruster);

        // Drone Mesh (Initially Hidden)
        const droneGeo = new THREE.OctahedronGeometry(0.3, 0);
        const droneMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.drone, wireframe: true });
        const droneMesh = new THREE.Mesh(droneGeo, droneMat);
        droneMesh.visible = false;
        playerGroup.add(droneMesh);


        // --- OBJECT POOLING ---
        class Pool {
            constructor(createFn, count) {
                this.createFn = createFn;
                this.pool = [];
                this.active = [];
                for (let i = 0; i < count; i++) {
                    const obj = createFn();
                    obj.visible = false;
                    scene.add(obj);
                    this.pool.push(obj);
                }
            }

            get() {
                if (this.pool.length === 0) return null;
                const obj = this.pool.pop();
                obj.visible = true;
                this.active.push(obj);
                return obj;
            }

            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    obj.visible = false;
                    this.pool.push(obj);
                }
            }
            
            reset() {
                [...this.active].forEach(obj => this.release(obj));
            }
        }

        // Player Laser Pool (Now with homing logic)
        const laserPool = new Pool(() => {
            const geo = new THREE.BoxGeometry(0.1, 0.1, 2);
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.laser });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData = { velocity: new THREE.Vector3(), target: null };
            return mesh;
        }, 30);

        // Drone Laser Pool (Homing/Targeted)
        const droneLaserPool = new Pool(() => {
            const geo = new THREE.BoxGeometry(0.15, 0.15, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.droneLaser });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData = { velocity: new THREE.Vector3(), life: 0 };
            return mesh;
        }, 50);

        // Enemy Pool
        const enemyPool = new Pool(() => {
            const group = new THREE.Group();
            const geo = new THREE.IcosahedronGeometry(1, 0);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                emissive: CONFIG.colors.enemy,
                emissiveIntensity: 0.8,
                roughness: 0.2,
                metalness: 0.8,
                flatShading: true
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            const wireGeo = new THREE.WireframeGeometry(geo);
            const wireMat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const wire = new THREE.LineSegments(wireGeo, wireMat);
            
            group.add(mesh);
            group.add(wire);
            
            group.userData = { 
                velocity: new THREE.Vector3(), 
                rotateSpeed: new THREE.Vector3(),
                hp: CONFIG.enemyHP,
                maxHp: CONFIG.enemyHP
            };
            return group;
        }, 20);

        // Particle Pool (Used for Explosions AND Trails)
        const particlePool = new Pool(() => {
            const geo = new THREE.TetrahedronGeometry(0.2);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.userData = { velocity: new THREE.Vector3(), life: 0, decay: 2 };
            return mesh;
        }, 800); // Increased pool size for trails


        // --- INPUT HANDLING ---
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowUp' || e.code === 'KeyW') state.input.y = 1;
            if (e.code === 'ArrowDown' || e.code === 'KeyS') state.input.y = -1;
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.input.x = -1;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') state.input.x = 1;
            if (e.code === 'Space') state.input.shoot = true;
        });
        
        window.addEventListener('keyup', (e) => {
            if (['ArrowUp', 'KeyW', 'ArrowDown', 'KeyS'].includes(e.code)) state.input.y = 0;
            if (['ArrowLeft', 'KeyA', 'ArrowRight', 'KeyD'].includes(e.code)) state.input.x = 0;
            if (e.code === 'Space') state.input.shoot = false;
        });

        // Mouse Tracking
        const crosshairEl = document.getElementById('crosshair');
        window.addEventListener('mousemove', (e) => {
            state.mouse.x = e.clientX;
            state.mouse.y = e.clientY;
            
            // Update crosshair UI
            crosshairEl.style.left = e.clientX + 'px';
            crosshairEl.style.top = e.clientY + 'px';
        });

        // Mobile Touch
        const isMobile = 'ontouchstart' in window;
        if (isMobile) {
            document.getElementById('mobile-controls').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
            crosshairEl.style.display = 'none'; // Hide crosshair on mobile for now
            document.body.style.cursor = 'auto';

            const joystickZone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            let stickId = null;
            let stickStart = {x:0, y:0};

            document.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.clientX < window.innerWidth / 2) {
                        if (stickId === null) {
                            stickId = t.identifier;
                            stickStart = { x: t.clientX, y: t.clientY };
                            joystickZone.style.left = (t.clientX - 75) + 'px';
                            joystickZone.style.bottom = (window.innerHeight - t.clientY - 75) + 'px';
                            joystickZone.style.opacity = 1;
                        }
                    } else {
                        state.input.shoot = true;
                    }
                }
            }, {passive: false});

            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === stickId) {
                        const maxDist = 50;
                        let dx = t.clientX - stickStart.x;
                        let dy = t.clientY - stickStart.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist > maxDist) {
                            const ratio = maxDist / dist;
                            dx *= ratio;
                            dy *= ratio;
                        }
                        
                        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                        state.input.x = dx / maxDist;
                        state.input.y = -(dy / maxDist); 
                    }
                }
            }, {passive: false});

            document.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === stickId) {
                        stickId = null;
                        state.input.x = 0; state.input.y = 0;
                        knob.style.transform = `translate(-50%, -50%)`;
                        joystickZone.style.left = '40px'; joystickZone.style.bottom = '40px';
                    } else {
                        state.input.shoot = false;
                    }
                }
            });
        }

        // --- GAME FUNCTIONS ---

        function spawnEnemy() {
            const enemy = enemyPool.get();
            if (!enemy) return;

            const x = (Math.random() - 0.5) * 30;
            const y = (Math.random() - 0.5) * 15;
            enemy.position.set(x, y, -100);
            
            enemy.userData.rotateSpeed.set(
                Math.random() * 2,
                Math.random() * 2,
                Math.random() * 2
            );
            enemy.userData.hp = CONFIG.enemyHP; // Reset HP
            // Scale back to normal in case it was popped
            enemy.scale.setScalar(1);
        }

        function spawnParticle(pos, color, velocityScale = 1, life = 1.0) {
             const p = particlePool.get();
             if(p) {
                p.position.copy(pos);
                p.material.color.set(color);
                p.userData.velocity.set(
                    (Math.random() - 0.5) * velocityScale,
                    (Math.random() - 0.5) * velocityScale,
                    (Math.random() - 0.5) * velocityScale
                );
                p.userData.life = life;
                p.scale.setScalar(life); // scale matches life for fade
            }
        }

        function createExplosion(pos) {
            for(let i=0; i<15; i++) {
                spawnParticle(pos, CONFIG.colors.enemy, 10);
            }
        }

        function fireDroneLaser(target) {
            const laser = droneLaserPool.get();
            if(!laser) return;

            // Start at drone position (world space)
            const droneWorldPos = new THREE.Vector3();
            droneMesh.getWorldPosition(droneWorldPos);
            laser.position.copy(droneWorldPos);

            // Calculate direction to target (predicted slightly)
            const targetPos = target.position.clone().add(new THREE.Vector3(0,0, 20)); // Lead the target slightly
            const dir = new THREE.Vector3().subVectors(targetPos, droneWorldPos).normalize();
            
            laser.userData.velocity = dir.multiplyScalar(100); // Fast speed
            laser.userData.life = 2.0; // 2 seconds survival
            laser.lookAt(targetPos);
        }

        function updateScore(points) {
            state.score += points;
            document.getElementById('score-val').innerText = state.score;
            updateStoreUI();
        }

        const buyBtn = document.getElementById('buy-drone-btn');
        function updateStoreUI() {
            if (state.score >= CONFIG.droneCost && !state.hasDrone) {
                buyBtn.classList.add('available');
                buyBtn.disabled = false;
            } else {
                buyBtn.classList.remove('available');
                buyBtn.disabled = true; // Simple visual disable mostly
            }
            
            if (state.hasDrone) {
                buyBtn.innerText = "DRONE ACTIVE";
                buyBtn.style.color = "#fff";
                buyBtn.style.borderColor = "#fff";
                buyBtn.disabled = true;
            }
        }

        buyBtn.addEventListener('click', () => {
            if (state.score >= CONFIG.droneCost && !state.hasDrone) {
                updateScore(-CONFIG.droneCost);
                state.hasDrone = true;
                droneMesh.visible = true;
                updateStoreUI();
            }
        });

        function gameOver() {
            state.isRunning = false;
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('game-over').style.display = 'block';
            document.body.style.cursor = 'auto';
            crosshairEl.style.display = 'none';
        }

        function restartGame() {
            state.score = 0;
            state.isRunning = true;
            state.input.x = 0; state.input.y = 0; state.input.shoot = false;
            state.hasDrone = false;
            droneMesh.visible = false;
            buyBtn.innerText = `GET DRONE (${CONFIG.droneCost} PTS)`;
            buyBtn.style.color = "var(--neon-green)";
            buyBtn.style.borderColor = "var(--neon-green)";

            updateScore(0);
            document.getElementById('game-over').style.display = 'none';
            if (!isMobile) {
                document.body.style.cursor = 'none';
                crosshairEl.style.display = 'block';
            }

            playerGroup.position.set(0, 0, 0);
            laserPool.reset();
            droneLaserPool.reset();
            enemyPool.reset();
            particlePool.reset();
        }
        
        document.getElementById('restart-btn').addEventListener('click', restartGame);

        // --- MAIN LOOP ---
        const clock = new THREE.Clock();
        const box1 = new THREE.Box3();
        const box2 = new THREE.Box3();

        function animate() {
            requestAnimationFrame(animate);
            
            if (state.isPaused) return;

            const delta = clock.getDelta();
            const now = clock.getElapsedTime();

            sun.material.uniforms.uTime.value = now;

            if (state.isRunning) {
                // --- WORLD ---
                // gridHelper logic removed
                const positions = starField.geometry.attributes.position.array;
                for(let i=2; i<positions.length; i+=3) {
                    positions[i] += CONFIG.speed * 2 * delta;
                    if(positions[i] > 50) positions[i] = -250;
                }
                starField.geometry.attributes.position.needsUpdate = true;

                // --- PLAYER ---
                const targetX = state.input.x * CONFIG.shipSpeed * 30 * delta;
                const targetY = state.input.y * CONFIG.shipSpeed * 30 * delta;
                
                playerGroup.position.x += targetX;
                playerGroup.position.y += targetY;
                playerGroup.position.x = THREE.MathUtils.clamp(playerGroup.position.x, -CONFIG.shipBoundX, CONFIG.shipBoundX);
                playerGroup.position.y = THREE.MathUtils.clamp(playerGroup.position.y, -CONFIG.shipBoundY, CONFIG.shipBoundY);

                playerGroup.rotation.z = THREE.MathUtils.lerp(playerGroup.rotation.z, -state.input.x * 0.8, 0.1);
                playerGroup.rotation.x = THREE.MathUtils.lerp(playerGroup.rotation.x, state.input.y * 0.5, 0.1);
                
                thruster.scale.y = 1 + Math.sin(now * 20) * 0.2;

                // --- AIMING / CROSSHAIR LOGIC ---
                if (!isMobile) {
                    let closestDist = Infinity;
                    let potentialTarget = null;
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    const widthHalf = width / 2;
                    const heightHalf = height / 2;

                    // Scan enemies to see if they are under the crosshair
                    enemyPool.active.forEach(enemy => {
                        // Get screen position
                        const pos = enemy.position.clone();
                        pos.project(camera);

                        const x = (pos.x * widthHalf) + widthHalf;
                        const y = -(pos.y * heightHalf) + heightHalf;

                        // Dist to mouse
                        const dx = x - state.mouse.x;
                        const dy = y - state.mouse.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        // Threshold (50px) and must be in front of player
                        if (dist < 50 && dist < closestDist && enemy.position.z < playerGroup.position.z) {
                            closestDist = dist;
                            potentialTarget = enemy;
                        }
                    });

                    state.lockedTarget = potentialTarget;
                    if (state.lockedTarget) {
                        crosshairEl.classList.add('locked');
                    } else {
                        crosshairEl.classList.remove('locked');
                    }
                }

                // --- DRONE LOGIC ---
                if (state.hasDrone) {
                    // Orbit animation
                    droneMesh.position.x = Math.cos(now * 2.5) * 1.5;
                    droneMesh.position.y = Math.sin(now * 2.5) * 1.5;
                    droneMesh.rotation.x = now;
                    droneMesh.rotation.y = now;

                    // Auto-fire
                    if (now - state.lastDroneShot > CONFIG.droneFireRate) {
                        // Find targets
                        const targets = enemyPool.active.slice(0, 6); // Pick up to 6 targets
                        if (targets.length > 0) {
                            targets.forEach(target => fireDroneLaser(target));
                            state.lastDroneShot = now;
                        }
                    }
                }

                // --- PLAYER SHOOTING ---
                if (state.input.shoot && now - state.lastShot > CONFIG.fireRate) {
                    const laser = laserPool.get();
                    if (laser) {
                        laser.position.copy(playerGroup.position);
                        laser.position.z -= 1.5; 
                        
                        // Initialize Laser Velocity
                        laser.userData.target = state.lockedTarget;
                        laser.userData.velocity.set(0, 0, -100); // Base speed forward
                        laser.lookAt(laser.position.clone().add(laser.userData.velocity));

                        state.lastShot = now;
                    }
                }

                // --- UPDATE PLAYER LASERS ---
                for (let i = laserPool.active.length - 1; i >= 0; i--) {
                    const laser = laserPool.active[i];

                    // Homing Logic
                    if (laser.userData.target && laser.userData.target.visible && laser.userData.target.userData.hp > 0) {
                        const targetPos = laser.userData.target.position.clone();
                        const toTarget = targetPos.sub(laser.position).normalize();
                        const currentVel = laser.userData.velocity.clone().normalize();
                        
                        // Steer towards target (Linear Interpolation of velocity vector)
                        currentVel.lerp(toTarget, 8.0 * delta).normalize();
                        laser.userData.velocity.copy(currentVel.multiplyScalar(100));
                        laser.lookAt(laser.position.clone().add(laser.userData.velocity));
                    }

                    // Move
                    laser.position.addScaledVector(laser.userData.velocity, delta);

                    if (laser.position.z < -150 || laser.position.z > 20) {
                        laserPool.release(laser);
                    }
                }

                // --- UPDATE DRONE LASERS & TRAIL ---
                for (let i = droneLaserPool.active.length - 1; i >= 0; i--) {
                    const dLaser = droneLaserPool.active[i];
                    // Move
                    dLaser.position.addScaledVector(dLaser.userData.velocity, delta);
                    dLaser.userData.life -= delta;

                    // Trail Effect: Gradient Green -> Orange
                    if (Math.random() > 0.3) { // Don't spawn every frame, save perf
                        const tColor = new THREE.Color(CONFIG.colors.trailStart);
                        tColor.lerp(new THREE.Color(CONFIG.colors.trailEnd), Math.random());
                        spawnParticle(dLaser.position, tColor, 0.5, 0.5);
                    }

                    if (dLaser.userData.life <= 0 || dLaser.position.z < -150) {
                        droneLaserPool.release(dLaser);
                    }
                }

                // --- SPAWN ENEMIES ---
                if (Math.random() < 0.05) spawnEnemy();

                // --- UPDATE ENEMIES & COLLISIONS ---
                const playerRadius = 1.0;
                
                for (let i = enemyPool.active.length - 1; i >= 0; i--) {
                    const enemy = enemyPool.active[i];
                    
                    enemy.position.z += CONFIG.speed * delta;
                    enemy.rotation.x += enemy.userData.rotateSpeed.x * delta;
                    enemy.rotation.y += enemy.userData.rotateSpeed.y * delta;

                    if (enemy.position.z > 20) {
                        enemyPool.release(enemy);
                        continue;
                    }

                    // 1. Player Collision
                    const distToPlayer = enemy.position.distanceTo(playerGroup.position);
                    if (distToPlayer < (1.5 + playerRadius)) { 
                        createExplosion(playerGroup.position);
                        gameOver();
                    }

                    // 2. Player Laser Collision (Insta-kill)
                    box1.setFromObject(enemy);
                    for (let j = laserPool.active.length - 1; j >= 0; j--) {
                        const laser = laserPool.active[j];
                        box2.setFromObject(laser);
                        
                        if (box1.intersectsBox(box2)) {
                            enemy.userData.hp -= CONFIG.playerDmg;
                            spawnParticle(enemy.position, 0xffffff, 5); // Hit effect
                            laserPool.release(laser);
                            
                            if (enemy.userData.hp <= 0) {
                                createExplosion(enemy.position);
                                enemyPool.release(enemy);
                                updateScore(100);
                            }
                            break; 
                        }
                    }

                    // 3. Drone Laser Collision (Chip damage)
                    if (enemy.userData.hp > 0) { // Check if still alive from player laser
                        for (let k = droneLaserPool.active.length - 1; k >= 0; k--) {
                            const dLaser = droneLaserPool.active[k];
                            // Simple distance check for drone lasers is cheaper than Box3 re-calc
                            if (dLaser.position.distanceTo(enemy.position) < 2.0) {
                                enemy.userData.hp -= CONFIG.droneDmg;
                                spawnParticle(dLaser.position, 0x00ff00, 2); // Green hit spark
                                droneLaserPool.release(dLaser);

                                if (enemy.userData.hp <= 0) {
                                    createExplosion(enemy.position);
                                    enemyPool.release(enemy);
                                    updateScore(100);
                                    break; // Enemy dead
                                }
                            }
                        }
                    }
                }

                // --- UPDATE PARTICLES ---
                for (let i = particlePool.active.length - 1; i >= 0; i--) {
                    const p = particlePool.active[i];
                    p.userData.life -= delta * p.userData.decay; // fade speed
                    
                    if (p.userData.life <= 0) {
                        particlePool.release(p);
                    } else {
                        p.position.addScaledVector(p.userData.velocity, delta);
                        p.scale.setScalar(p.userData.life);
                        p.rotation.x += 10 * delta;
                    }
                }
            }

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>